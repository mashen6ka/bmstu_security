## Лабы:

1. Программа, работающая по UUID устройства (Hardware ID для macOS)
2. Энигма
3. DES
4. RSA
5. Электронная подпись
6. Алгоритм Хаффмана

## Вопросы:

### 1. Программа, работающая по UUID устройства

> Что за идентификатор используется, откуда берется?

Hardware UUID (About this Mac -> System Report -> Hardware -> Hardware UUID)

Два варинта получения:

1. `ioreg -d2 -c IOPlatformExpertDevice | awk -F\" '/IOPlatformUUID/{print $(NF-1)}'`
2. `system_profiler SPHardwareDataType | awk '/UUID/{print $3;}'`

> Пояснить команды получения параметра.

- `ioreg`
  - `ioreg` - реестр устройств ввода-вывода, инвертированное дерево
  - `-d2` - глубина дерева
  - `-c IOPlatformExpertDevice` - класс _IOPlatformExpertDevice_
  - `awk` - выборка отдельного фрагмента текста
  - `-F\"` - сепаратор
- `system_profiler`
  - `system_profiler` - планировщик системы
  - `SPHardwareDataType` - информация о железе
  - `awk` - выборка отдельного фрагмента текста

> Критерии выбора идентификатора.

1. Уникальность
2. Постоянность (неизменность)
3. Доступность (можем специальными командами его получить)

### 2. Энигма

> Почему элементы рефлектора повторяются?

Рефлектор реализовывает симметричную замену одного символа на другой (если a -> b, то b -> a).

У меня в реализации там просто массив чисел от 0 до 255, в котором нет повторений. Там прекол в том, что на позиции 0 стоит значение 255, а на 255 - 0, и т.д. Просто в реализации используются не мапы, а списки, в которых рассматриваются элементы и их индексы.

> Реализация ротора. Как они вращаются?

Ротор содержит список значений, стартовую позицию (чтобы имитировать цикличность ротора в реальной жизни) и текущую установленную позицию.

У меня такая схема энигмы:

Рефлектор - Ротор3 - Ротор2 - Ротор1

Роторы прокручиваются по окончании обратного хода следующим образом:

- Ротор3 поворачивается каждый раз
- Ротор2 поворачивается каждый раз, когда Ротор3 сделает полный оборот
- Ротор1 поворачивается каждый раз, когда Ротор2 сделает полный оборот

> Заполнение рефлектора. Главное его свойство и зачем оно нужно.

В моей реализации идем по числам от 0 до 255 и кладем их в список в обратном порядке.

Главное свойство - симметричность (если a -> b, то b -> a), оно позволяет использовать один и тот же алгоритм как для шифрования, так и для расшифровки.

> Чем отличается процесс шифрования от расшифровки?

Ничем. Как раз-таки за счет свойства рефлектора.

> Как работает рефлектор?

По факту это просто табличка соответствий. Возвращает символ, который поставлен в соответствие переданному.

> Чем отличается рефлектор от ротора?

Вопрос странный, потому что типа всем... Ну ротор вращается, а рефлектор статичный и просто возвращает символ, соответствующий переданному.

> Как отличается размер шифрованного файла от начального?

Никак, размер байт в байт.

> Если длина исходного текста = n, сколько раз повернется каждый ротор?

У меня такая схема энигмы:

Рефлектор - Ротор3 - Ротор2 - Ротор1

Соответственно, Ротор3 провернется n раз, Ротор2 - n // 256, Ротор1 - n // (256)\*\*2

> Чем отличается прямой и обратный ход?

В процессе прямого хода мы используем входное значение как индекс элемента в списке значений ротора и вытаскиваем по этому индексу значение, а в процессе обратного хода используем входное значение как значение и ищем его индекс в списке значений ротора.

### 3. DES

> Функция Фейстеля.
> (это вот то, что находится внутри цикла по 16 ранудовым ключам)

Предварительно делим текущий блок (8 байт) пополам на `Left` и `Right` части.

16 раундов:

1. Расширяем `Right` блок до 48 бит (расширяющей подстановкой), записываем полученное значение в переменную `Temp`.
2. `Temp = xor(Temp, текущий ключ)`. Для шифрования iй ключ, для расшифровки - (15 - i)й.
3. Блок подстановок для `Temp`, по итогу которого из 48 бит получаем 32 бита (см. некст вопрос для подробного объяснения блока подстановок).
4. Раундовая перестановка для `Temp`.
5. `Temp = xor(Left, Temp)`.
6. `swap(Left, Right) swap(R, T)`.

По итогу записываем в результат финальную перестановку для `Right + Left` (вот тут как раз затесался обратный своп, см. вопросы ниже про него)

> Как достается значение из блока подстановок и что им заменяется?

(функция `__sboxSubstitute`)

Расширенный до 48 бит `Right` блок ксорим с нужным ключом и записываем полученное значение в некую переменную `Temp`, для которой работаем с блоком подстановок.

Делим `Temp` на куски по 6 бит (8 шт) и проходимся по таблице подстановок:

- `row = int(0й бит + 5й бит)`
- `column = int(2й бит + 3й бит + 4й бит + 5й бит)`

Берем двоичное значение элемента текущей матрицы по найденным `row` и `column` (4 бита).

Склеиваем полученные 4битные кусочки (8 шт) вместе и заменяем полученным значением значение `Temp`.

> Чем отличается процесс шифрования от расшифровки?

При шифровании прямой порядок обхода списка ключей, а при расшифровке - обратный.

В остальном процессы идентичны, что достигается благодаря обратному свопу половинок в конце.

> Зачем в конце производим обратный своп?

За счет этого достигается симметричность алгоритма, т.е. возможно использование одного и того же метода как для шифрования, так и для расшифровки

> Как работает расширяющая подстановка?

В таблице расширяющей подстановки 48 значений, в рассматриваемом блоке текста - 32 бита. Проходимся по всем значениям таблицы и в результирующую строку (список) закидываем значение из блока текста, хранящееся по индексу, равному текущему элементу таблицы.

`return [array[element - 1] for element in table]`, где `array` - исходный блок текста, а `table` - таблица расширяющей подстановки.

> Какие данные используются для перестановок?

Таблицы перстановок, видимо.

> Как генерируются раундовые ключи?

Изначально задан ключ 8 байт, бьем его на биты и применяем первую перестановку для ключа, после которой получаем ключ размером в 56 бит (принцип перестановки аналогичен принципу расширяющей подстановки, см. выше).

Полученный ключ делим на блоки `Left` и `Right` по 28 бит.

16 раундов:

1. Сдвиг влево обоих блоков по таблице сдвигов.
2. Склеиваем `Left` и `Right`.
3. Проводим вторую перестановку для ключа (склеенного), получаем 48битный ключ, который закидываем в список ключей.

> Что происходит с файлами, размер которых не кратен 8?

Вычисляется значение `paddingLength = 8 - (len(data) % 8)`.
Ко всем файлам в конец закидывается значение `paddingLength` ровно `paddingLength` раз (например, если `paddingLength = 2`, то доп строка = `22`, если `paddingLength = 5`, то доп строка = `55555` и т.д.). Т.е. даже если длина кратна 8, файл все равно дополняется (в таком случае 8мью символами). Тогда при расшифровке всегда считывается последнений символ (он содержит значение `paddingLength`) и с конца обрезается ровно `paddingLength` символов.
см. _PKCS5 standard_

> Особенность начальной и конечной подстановки?

Взаимно обратные

### 4. RSA

> Как генерируются значения p и q?

Используя решето Эратосфена генерируем простые числа в нужном диапазоне, после чего выбираем неравные друг другу значения из этого списка.

> Как значения проверяются на простоту?

Не очень понятно, какие значения: p и q изначально генерим как простые числа, а вот когда вычисляем e, то проверяем, что `НОД(e, phi) = 1`, чтобы они были взаимно простыми.

> Как связаны ключи (e и d)?

Взаимно обратны по модулю `phi(n)`.

> Расширенный алгоритм Евклида.

(см. функцию \_\_modInverseExtendedEuclid)

Мы используем алгоритм, чтобы найти такое значение d, чтобы e и d были взаимно обратны по модулю phi. Соответственно, на вход алгоритму отдаем phi и e.

```
Пусть u2 и v2 - некоторые коэффициенты, такие, что:

u2 * phi + v2 * e = НОД(phi, e)

Мы находили e таким образом, чтобы значение было взаимно простым с phi, т.е. НОД(phi, e) = 1, откуда:

u2 * phi + v2 * e = 1
v2 * e - 1 = -u2 * phi

=> v2 * e - 1 делится на phi
=> v2 * e = 1 (mod phi)
```

Т.е. v2 - искомое значение d.

Теперь к самому алгоритму.

(см. функцию \_\_gcdExtended)

```
num1, num2 = phi, e

q = num1 // num2 - целое
r = num1 % num2 - остаток

num1 = num2 * q + r => r = num1 - num2 * q

Имея u1 = 1, v1 = 0, u2 = 0, v2 = 1, можем составить линейные комбинации:
num1 = u1 * num1 + v1 * num2
num2 = u2 * num1 + v2 * num2

Теперь подставим их в выражение для r:
r = u1 * num1 + v1 * num2 - q * (u2 * num1 + v2 * num2)
r = num1 * (u1 - u2 * q) + num2 * (v1 - v2 * q)

Получили коэффициенты (u1 - u2 * q) и (v1 - v2 * q)

Теперь рекурсивно вызываем ту же функцию с обновленными значениями:
num1 = num2
num2 = r
u1, v1 = u2, v2
u2, v2 = u1 - q * u2, v1 - q * v2

Так в num2 накопим НОД, а в u2, v2 - искомые коэффициенты.
```

В итоге полученное значение (найденный коэффициент) берем по модулю phi, что гарантирует нам его неотрицательность.

> Чем отличается обычный алгоритм Евклида от расширенного?

В обычном мы просто находим НОД для двух значений, а в расширенном, помимо НОД, получаем еще коэффициенты Безу.

Если a и b - исходные числа, то x, y - эти самые коэффициенты, причем такие, что `ax + by = НОД(a, b)`.

> Отличается ли размер шифрованного файла от начального?

Yes. Причем в зависимости от заданно длины ключа может очень сильно отличаться. Мы по факту каждый байт исходного текста переводим в какое-то числовое значение, которое может представляться несколькими байтами.

> За счет чего устанавливается ограничение длины одного символа?

За счет n. Мы получаем новое значение символа, возводя исходное в некоторую степень по модулю n, соответственно новое значение не будет превышать n.

> Почему ключ d неотрицательный?

Мы его используем для возведения значения в степень, отрицательная степень нам не нужна.

### 5. Электронная подпись

> Алгоритм подписи.

Генерируем приватный (d , n) и публичный (e, n) ключ на основе RSA.

Хэшируем данные, которые нужно подписать (h).

С помощью приватного ключа шифруем хэшированные данные: `s = h**d mod n`, по итогу получаем подпись (s). Полученную подпись и публичный ключ сохраняем (я в отдельные файлы).

> Алгоритм верификации.

Хэшируем данные, которые нужно проверить (h).

С помощью публичного ключа (e, n) расшифровываем подпись (s): `h' = s**e mod n`, после чего сравниваем исходный хэш (h) и полученный (h'). Если они совпали, то верификация успешна (данные подписаны человеком, чей публичный ключ использовался), иначе - провал.

> Какие алгоритмы хэширования и шифрования можно использовать для подписи?

Алгоритмы хэширования любые, алгоритмы шифрования - ассиметричные.

> В чем особенность использования алгоритма RSA для подписи?

По умолчанию алгоритм использовался так:

- у юзера А есть приватный и публичный ключ
- юзер Б шифрует данные, используя публичный ключ юзера А
- юзер А расшифровывает данные, используя свой приватный ключ

А в подписи у нас по факту наоборот: приватный ключ используется, чтобы зашифровать данные и получить подпись, а публичный - для расшифровки и верификации подписи.

### 6. Алгоритм Хаффмана

> Построение дерева.

Прошлись по списку байт, составили табличку часточ появления каждого байта.

Идем по табличке частот и закидываем в очередь с приоритетом узел, содержащий значение байта и частоту его появления (приоритет в очереди по частоте, от меньшей к большей).

Потом идем по очереди до тех пор, пока в ней не останется один элемент (он будет корневым элементом дерева). Вытаскиваем первые два узла `Node1` и `Node2` из очереди (они будут иметь наименьшую частоту) и на их основе создаем узел следующим образом:

- байт: None
- частота: частота `Node1` + частота `Node2`
- левый потомок: `Node1`
- правый потомок: `Node2`

Созданный узел закидываем обратно в очередь с приоритетом (не нарушая правило приоритетности).

Все то же самое повторяем до самого конца. Таким образом, дерево будет потихоньку расти снизу вверх.

По итогу в очереди останется один элемент, являющийся корневым элементом дерева.

> Как решается проблема "лишних" битов?

`paddingLength = 8 - (len(bitStr) % 8)`.

Т.к. коды для байтов могут иметь совершенно разную длину, можем по итогу получить закодированную строчку, длина которой не будет кратна 8. Чтобы нормально записать ее в бинарный файл и потом считать, надо добить ее до кратного значения. Соответственно, в начало строки добавляется 8 бит, которые являются двоичным представлением кол-ва бит, которых не хватает строке до кратности 8 (например, если `paddingLength` = 3, то в начало строки записываем `00000011`). В конец файла, соответственно, закидывается нужное кол-во нулей (`paddingLength` штук).

При чтении сначала читаем первый байт, получаем число бит, которые нужно отрезать с конца строки (`paddingLength`), и, собственно, отрезаем их и первый байт, который содержит уже ненужную информацию.

> Как по дереву раскодировать файл?

Читаем наш текст прям по битам и начинаем обход дерева с корневого узла. Если текущий считанный бит - 0, переходим по левому ребру, если 1 - по правому. Идем так до тех пор, пока не упремся в конечный элемент, лист дерева, содержащий значение символа (байта). Значение закидываем в результирующий список, возвращаемся к корню дерева и идем так же дальше.

Мы можем вот так последовательно считывать бит за битом, потому что алгоритм гарантирует однозначное считывание кодов (префиксное правило). Суть в том, что никакой код не может быть префиксом другого.

> За счет чего происходит сжатие?

Наиболее часто встречаемые символы заменяются минимальным числом бит.

> Какова максимальная длина закодированного символа?

255 бит. Это возможно в том случае, если частоты появления символов образуют последовательность Фибоначчи.

> Что нужно сохранить, что раскодировать зашифрованный файл?

Достаточно сохранить таблицу частот, чтобы по ней снова можно было составить дерево, но можно сохранять и само дерево.

Вообще по-хорошему надо бы само дерево тоже писать в шифруемый файл, но я не запаривалась и просто в классе его хранила.
